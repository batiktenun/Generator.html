<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mockup Generator — Masked (PNG alpha)</title>
<style>
:root{--accent:#0b66ff}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto;display:flex;gap:20px;padding:20px;background:#f6f7fb;color:#0b0b0b}
.panel{width:380px;background:#fff;border-radius:12px;box-shadow:0 6px 18px rgba(20,20,40,.08);padding:16px}
.preview-wrap{flex:1;display:flex;flex-direction:column;gap:12px}
.preview{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fafafa);padding:12px;border-radius:12px}
canvas{background:#fff;border-radius:8px;box-shadow:0 6px 18px rgba(20,20,40,.06);max-width:100%;height:auto}
label{display:block;font-size:13px;margin-top:10px;color:#444}
input[type=file]{display:block;margin-top:6px}
.row{display:flex;gap:8px;align-items:center}
.controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;align-items:center}
input[type=range]{width:100%}
button{background:var(--accent);color:#fff;border:0;padding:9px 12px;border-radius:8px;cursor:pointer}
.small{font-size:12px;color:#666}
.footer{font-size:12px;color:#666;margin-top:12px;text-align:center}
.switch{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>

<div class="panel">
  <h3>Mockup — Masked PNG (alpha)</h3>
  <div class="small">Gunakan PNG baju dengan background transparan. Motif hanya tampil di area non-transparent (alpha mask).</div>

  <label>1) Upload Foto Baju (PNG transparan)</label>
  <input id="shirtFile" type="file" accept="image/*">

  <label>2) Upload Motif</label>
  <input id="patternFile" type="file" accept="image/*">

  <label>3) Transform</label>
  <div class="row">
    <span style="width:70px">Pos X</span><input id="posX" type="range" min="-2000" max="2000" value="450">
  </div>
  <div class="row">
    <span style="width:70px">Pos Y</span><input id="posY" type="range" min="-2000" max="2000" value="550">
  </div>
  <div class="row">
    <span style="width:70px">Scale</span><input id="scale" type="range" min="0.1" max="5" step="0.01" value="1">
  </div>
  <div class="row">
    <span style="width:70px">Rotasi</span><input id="rotation" type="range" min="-180" max="180" value="0">
  </div>
  <div class="row">
    <span style="width:70px">Opacity</span><input id="opacity" type="range" min="0" max="1" step="0.01" value="1">
  </div>

  <div class="controls-grid" style="margin-top:8px">
    <div class="row"><button id="centerBtn" style="flex:1">Center</button></div>
    <div class="row"><button id="tileBtn" style="width:110px">Toggle Tile</button></div>
  </div>

  <label style="margin-top:12px">4) Displacement</label>
  <div class="row">
    <div class="switch"><input id="displaceToggle" type="checkbox"><label for="displaceToggle" class="small">Aktifkan</label></div>
    <div style="flex:1"><input id="displaceStrength" type="range" min="0" max="120" value="18"></div>
  </div>

  <label style="margin-top:12px">5) Aksi</label>
  <div class="row">
    <button id="downloadBtn">Download PNG</button>
    <button id="resetBtn" style="background:#eee;color:#111">Reset</button>
  </div>

  <div id="tips" class="small">Tip: gunakan PNG baju dengan area transparan di luar baju. Foto ≤ 2000px disarankan agar cepat.</div>
  <div class="footer">Copy–paste file ini ke GitHub sebagai index.html — siap pakai.</div>
</div>

<div class="preview-wrap">
  <div class="preview">
    <canvas id="c" width="900" height="1100" aria-label="mockup canvas"></canvas>
  </div>
  <div style="display:flex;gap:12px;align-items:flex-start">
    <div>
      <div class="small">Live Preview</div>
      <img id="livePreview" alt="Live preview" src="" style="width:220px;border-radius:8px;border:1px solid #eee;background:#fff;margin-top:6px">
    </div>
    <div>
      <div class="small">Small Preview</div>
      <img id="smallPreview" alt="Small preview" src="" style="width:140px;border-radius:8px;border:1px solid #eee;background:#fff;margin-top:6px">
    </div>
  </div>
</div>

<script>
/* Mask-from-PNG alpha + manual control + displacement */

// Main canvas
const c = document.getElementById('c');
const ctx = c.getContext('2d');

let shirtImg = null;      // shirt image (PNG with alpha)
let patternImg = null;    // motif image
let maskCanvas = null;    // mask built from shirt alpha
let lumMap = null;        // luminance map for displacement (from shirt rgb)
let patternState = { x: c.width/2, y: c.height/2, scale: 1, rot: 0, alpha: 1, tiled: false };
let dragging = false;
let dragOffset = { x:0, y:0 };

// UI refs
const shirtFile = document.getElementById('shirtFile');
const patternFile = document.getElementById('patternFile');
const posX = document.getElementById('posX');
const posY = document.getElementById('posY');
const scaleEl = document.getElementById('scale');
const rotationEl = document.getElementById('rotation');
const opacityEl = document.getElementById('opacity');
const centerBtn = document.getElementById('centerBtn');
const tileBtn = document.getElementById('tileBtn');
const displaceToggle = document.getElementById('displaceToggle');
const displaceStrength = document.getElementById('displaceStrength');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const livePreview = document.getElementById('livePreview');
const smallPreview = document.getElementById('smallPreview');

// load images from file input
function loadImageFromFile(file, cb){
  const r = new FileReader();
  r.onload = e => {
    const img = new Image();
    img.onload = () => cb(img);
    img.src = e.target.result;
  };
  r.readAsDataURL(file);
}

// when shirt uploaded
shirtFile.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  loadImageFromFile(f, img=>{
    shirtImg = img;
    fitCanvasToShirt();
    generateMaskFromShirt();   // mask from alpha channel
    computeLuminanceMap();     // used for displacement
    draw();
  });
});

// when motif uploaded
patternFile.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  loadImageFromFile(f, img=>{
    patternImg = img;
    patternState.x = c.width/2;
    patternState.y = c.height/2;
    patternState.scale = 1;
    patternState.rot = 0;
    patternState.alpha = 1;
    patternState.tiled = false;
    syncUI();
    draw();
  });
});

// fit canvas size to shirt (maintain ratio)
function fitCanvasToShirt(){
  if(!shirtImg) return;
  const maxW = 1400, maxH = 1700;
  let w = shirtImg.naturalWidth || shirtImg.width;
  let h = shirtImg.naturalHeight || shirtImg.height;
  const ratio = Math.min(maxW / w, maxH / h, 1);
  c.width = Math.round(w * ratio);
  c.height = Math.round(h * ratio);
  // recompute mask/lum when resized
  if(shirtImg){ generateMaskFromShirt(); computeLuminanceMap(); }
  if(!patternImg){ patternState.x = c.width/2; patternState.y = c.height/2; }
  syncUI();
}

// Generate maskCanvas from shirt PNG alpha channel
function generateMaskFromShirt(){
  if(!shirtImg) { maskCanvas = null; return; }
  const tmp = document.createElement('canvas');
  tmp.width = c.width; tmp.height = c.height;
  const tctx = tmp.getContext('2d');
  // draw shirt to tmp at canvas size (this preserves alpha)
  tctx.clearRect(0,0,tmp.width,tmp.height);
  tctx.drawImage(shirtImg, 0, 0, tmp.width, tmp.height);
  const id = tctx.getImageData(0,0,tmp.width,tmp.height);
  const data = id.data;

  // create mask canvas: where alpha > threshold => opaque, else transparent
  const mask = document.createElement('canvas');
  mask.width = tmp.width; mask.height = tmp.height;
  const mctx = mask.getContext('2d');
  const mImage = mctx.createImageData(tmp.width, tmp.height);
  const mData = mImage.data;

  const threshold = 10; // alpha threshold (0-255). adjust if needed.

  for(let i=0;i<data.length;i+=4){
    const a = data[i+3]; // alpha of shirt source
    if(a > threshold){
      // keep white opaque (mask)
      mData[i] = 255; mData[i+1] = 255; mData[i+2] = 255; mData[i+3] = 255;
    } else {
      // transparent
      mData[i] = 0; mData[i+1] = 0; mData[i+2] = 0; mData[i+3] = 0;
    }
  }
  mctx.putImageData(mImage, 0, 0);
  maskCanvas = mask;
}

// compute luminance map (for displacement) from shirt visual (RGB)
function computeLuminanceMap(){
  if(!shirtImg) { lumMap = null; return; }
  const tmp = document.createElement('canvas');
  tmp.width = c.width; tmp.height = c.height;
  const tctx = tmp.getContext('2d');
  tctx.clearRect(0,0,tmp.width,tmp.height);
  tctx.drawImage(shirtImg, 0, 0, tmp.width, tmp.height);
  const id = tctx.getImageData(0,0,tmp.width,tmp.height).data;
  lumMap = new Float32Array(tmp.width * tmp.height);
  for(let i=0, j=0; i<id.length; i+=4, j++){
    lumMap[j] = (0.2126*id[i] + 0.7152*id[i+1] + 0.0722*id[i+2]) / 255;
  }
  lumMap = boxBlurFloat(lumMap, tmp.width, tmp.height, 2);
}

// separable box blur for Float32Array
function boxBlurFloat(arr,w,h,radius){
  if(radius < 1) return arr;
  const tmp = new Float32Array(arr.length);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let sum=0,cnt=0;
      for(let k=-radius;k<=radius;k++){
        const xx = x+k;
        if(xx>=0 && xx<w){ sum += arr[y*w + xx]; cnt++; }
      }
      tmp[y*w + x] = sum / cnt;
    }
  }
  const out = new Float32Array(arr.length);
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0,cnt=0;
      for(let k=-radius;k<=radius;k++){
        const yy = y+k;
        if(yy>=0 && yy<h){ sum += tmp[yy*w + x]; cnt++; }
      }
      out[y*w + x] = sum / cnt;
    }
  }
  return out;
}

// draw main canvas (shirt already drawn first)
function draw(){
  ctx.clearRect(0,0,c.width,c.height);

  // draw shirt (preserve alpha)
  if(shirtImg){
    ctx.drawImage(shirtImg, 0, 0, c.width, c.height);
  } else {
    drawCheckerBackground(ctx, c.width, c.height);
  }

  if(!patternImg){
    updatePreviews();
    return;
  }

  // 1) draw transformed motif into patternCanvas
  const pw = c.width, ph = c.height;
  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = pw; patternCanvas.height = ph;
  const pctx = patternCanvas.getContext('2d');
  pctx.clearRect(0,0,pw,ph);

  pctx.save();
  pctx.translate(patternState.x, patternState.y);
  pctx.rotate(patternState.rot * Math.PI/180);
  pctx.scale(patternState.scale, patternState.scale);

  if(patternState.tiled){
    const patt = pctx.createPattern(patternImg, 'repeat');
    pctx.fillStyle = patt;
    const fillW = pw * (1/patternState.scale) + 1000;
    const fillH = ph * (1/patternState.scale) + 1000;
    pctx.fillRect(-fillW/2, -fillH/2, fillW, fillH);
  } else {
    const w = patternImg.naturalWidth || patternImg.width;
    const h = patternImg.naturalHeight || patternImg.height;
    const defaultScale = Math.min((pw * 0.6) / w, (ph * 0.6) / h);
    const drawW = w * defaultScale;
    const drawH = h * defaultScale;
    pctx.drawImage(patternImg, -drawW/2, -drawH/2, drawW, drawH);
  }
  pctx.restore();

  // 2) If displacement disabled or no lumMap -> draw patternCanvas directly but masked
  if(!displaceToggle.checked || !lumMap){
    // draw pattern on top, then apply mask so motif only appears inside shirt alpha
    ctx.globalAlpha = patternState.alpha;
    // draw pattern
    ctx.drawImage(patternCanvas, 0, 0);
    // apply mask if exists
    if(maskCanvas){
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(maskCanvas, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
    }
    ctx.globalAlpha = 1;
    updatePreviews();
    return;
  }

  // 3) displacement: sample pixels from patternCanvas guided by lumMap gradients -> build displaced canvas
  const pData = pctx.getImageData(0,0,pw,ph).data;
  const displaced = document.createElement('canvas');
  displaced.width = pw; displaced.height = ph;
  const dctx = displaced.getContext('2d');
  const out = dctx.createImageData(pw, ph);
  const outData = out.data;
  const strength = Number(displaceStrength.value);

  // compute gradient of lumMap
  const gx = new Float32Array(pw*ph);
  const gy = new Float32Array(pw*ph);
  for(let y=0;y<ph;y++){
    for(let x=0;x<pw;x++){
      const i = y*pw + x;
      const left = x>0 ? lumMap[i-1] : lumMap[i];
      const right = x<pw-1 ? lumMap[i+1] : lumMap[i];
      const top = y>0 ? lumMap[i-pw] : lumMap[i];
      const bottom = y<ph-1 ? lumMap[i+pw] : lumMap[i];
      gx[i] = right - left;
      gy[i] = bottom - top;
    }
  }

  // sample from patternCanvas with displacement offsets
  for(let y=0;y<ph;y++){
    for(let x=0;x<pw;x++){
      const i = y*pw + x;
      const dx = -gx[i] * (strength/50);
      const dy = -gy[i] * (strength/50);
      let sx = Math.round(x + dx), sy = Math.round(y + dy);
      if(sx<0) sx=0; if(sx>=pw) sx=pw-1;
      if(sy<0) sy=0; if(sy>=ph) sy=ph-1;
      const si = (sy*pw + sx)*4, oi = i*4;
      outData[oi]   = pData[si];
      outData[oi+1] = pData[si+1];
      outData[oi+2] = pData[si+2];
      outData[oi+3] = pData[si+3]; // preserve pattern alpha
    }
  }
  dctx.putImageData(out, 0, 0);

  // 4) blend displaced onto main canvas (shirt already drawn), then apply mask (destination-in)
  ctx.globalAlpha = patternState.alpha;
  ctx.globalCompositeOperation = 'multiply';
  ctx.drawImage(displaced, 0, 0);
  ctx.globalCompositeOperation = 'source-over';

  // apply mask so motif only visible inside shirt alpha
  if(maskCanvas){
    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(maskCanvas, 0, 0);
    ctx.globalCompositeOperation = 'source-over';
  }
  ctx.globalAlpha = 1;

  updatePreviews();
}

// previews update
function updatePreviews(){
  try{
    const data = c.toDataURL('image/png');
    livePreview.src = data;
    smallPreview.src = data;
  }catch(e){}
}

// checker draw for empty shirt
function drawCheckerBackground(context,w,h){
  const size = 16;
  for(let y=0;y<h;y+=size){
    for(let x=0;x<w;x+=size){
      const even = ((x/size)+(y/size))%2===0;
      context.fillStyle = even ? '#f8f8f8' : '#efefef';
      context.fillRect(x,y,size,size);
    }
  }
}

// sync UI
function syncUI(){
  posX.value = Math.round(patternState.x);
  posY.value = Math.round(patternState.y);
  scaleEl.value = patternState.scale;
  rotationEl.value = patternState.rot;
  opacityEl.value = patternState.alpha;
}

// pointer drag for motif
c.addEventListener('pointerdown', e=>{
  if(!patternImg) return;
  const rect = c.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const w = (patternImg.naturalWidth || patternImg.width) * Math.min((c.width*0.6)/(patternImg.naturalWidth||patternImg.width),(c.height*0.6)/(patternImg.naturalHeight||patternImg.height)) * patternState.scale;
  const h = (patternImg.naturalHeight || patternImg.height) * Math.min((c.width*0.6)/(patternImg.naturalWidth||patternImg.width),(c.height*0.6)/(patternImg.naturalHeight||patternImg.height)) * patternState.scale;
  const dx = x - patternState.x; const dy = y - patternState.y;
  const theta = -patternState.rot * Math.PI/180;
  const rx = dx * Math.cos(theta) - dy * Math.sin(theta);
  const ry = dx * Math.sin(theta) + dy * Math.cos(theta);
  if(Math.abs(rx) <= w/2 + 20 && Math.abs(ry) <= h/2 + 20){
    dragging = true; dragOffset.x = dx; dragOffset.y = dy; c.setPointerCapture(e.pointerId);
  }
});
c.addEventListener('pointermove', e=>{
  if(!dragging) return;
  const rect = c.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  patternState.x = x - dragOffset.x;
  patternState.y = y - dragOffset.y;
  syncUI(); draw();
});
c.addEventListener('pointerup', e=>{ dragging=false; try{ c.releasePointerCapture(e.pointerId);}catch(e){} });
c.addEventListener('pointercancel', ()=>{ dragging=false; });

// sliders listeners
[posX,posY,scaleEl,rotationEl,opacityEl,displaceStrength].forEach(el=>{
  el.addEventListener('input', ()=>{
    patternState.x = Number(posX.value);
    patternState.y = Number(posY.value);
    patternState.scale = Number(scaleEl.value);
    patternState.rot = Number(rotationEl.value);
    patternState.alpha = Number(opacityEl.value);
    draw();
  });
});

// center/tile/reset
centerBtn.addEventListener('click', ()=>{ patternState.x = c.width/2; patternState.y = c.height/2; syncUI(); draw(); });
tileBtn.addEventListener('click', ()=>{ patternState.tiled = !patternState.tiled; tileBtn.textContent = patternState.tiled ? 'Tile: ON' : 'Toggle Tile'; draw(); });
resetBtn.addEventListener('click', ()=>{ shirtImg=null; patternImg=null; maskCanvas=null; lumMap=null; patternState={x:c.width/2,y:c.height/2,scale:1,rot:0,alpha:1,tiled:false}; document.getElementById('shirtFile').value=''; document.getElementById('patternFile').value=''; syncUI(); draw(); });

// DOWNLOAD (high-res, with mask)
downloadBtn.addEventListener('click', ()=>{
  if(!shirtImg && !patternImg) return;
  const scaleFactor = 2;
  const tmp = document.createElement('canvas');
  tmp.width = c.width * scaleFactor;
  tmp.height = c.height * scaleFactor;
  const tctx = tmp.getContext('2d');

  // draw shirt (scaled)
  if(shirtImg) tctx.drawImage(shirtImg, 0, 0, tmp.width, tmp.height);
  else drawCheckerBackground(tctx, tmp.width, tmp.height);

  // build high-res pattern canvas
  const pCanvas = document.createElement('canvas');
  pCanvas.width = tmp.width; pCanvas.height = tmp.height;
  const pctx = pCanvas.getContext('2d');
  pctx.save();
  pctx.translate(patternState.x * scaleFactor, patternState.y * scaleFactor);
  pctx.rotate(patternState.rot * Math.PI/180);
  pctx.scale(patternState.scale, patternState.scale);
  if(patternState.tiled){
    const patt = pctx.createPattern(patternImg, 'repeat'); pctx.fillStyle = patt;
    pctx.fillRect(-pCanvas.width, -pCanvas.height, pCanvas.width*2, pCanvas.height*2);
  } else {
    const w = patternImg.naturalWidth || patternImg.width;
    const h = patternImg.naturalHeight || patternImg.height;
    const defaultScale = Math.min((pCanvas.width * 0.6) / w, (pCanvas.height * 0.6) / h);
    const drawW = w * defaultScale;
    const drawH = h * defaultScale;
    pctx.drawImage(patternImg, -drawW/2, -drawH/2, drawW, drawH);
  }
  pctx.restore();

  if(!displaceToggle.checked || !lumMap){
    tctx.globalAlpha = patternState.alpha;
    tctx.drawImage(pCanvas, 0, 0);
    // apply mask (if png mask exists): draw mask scaled
    if(maskCanvas){
      const mCanvas = document.createElement('canvas'); mCanvas.width = tmp.width; mCanvas.height = tmp.height;
      const mctx = mCanvas.getContext('2d');
      mctx.drawImage(maskCanvas, 0, 0, tmp.width, tmp.height);
      tctx.globalCompositeOperation = 'destination-in';
      tctx.drawImage(mCanvas, 0, 0);
      tctx.globalCompositeOperation = 'source-over';
    }
    tctx.globalAlpha = 1;
    const link = document.createElement('a'); link.download = 'mockup.png'; link.href = tmp.toDataURL('image/png'); link.click();
    return;
  }

  // displacement high-res: scale luminance
  const scaledLum = scaleLumMap(lumMap, c.width, c.height, tmp.width, tmp.height);

  const pw = pCanvas.width, ph = pCanvas.height;
  const pData = pctx.getImageData(0,0,pw,ph).data;
  const displacedHR = document.createElement('canvas'); displacedHR.width = pw; displacedHR.height = ph;
  const dctxHR = displacedHR.getContext('2d');
  const out = dctxHR.createImageData(pw,ph);
  const outData = out.data;
  const strength = Number(displaceStrength.value);

  // gradient
  const gx = new Float32Array(pw*ph);
  const gy = new Float32Array(pw*ph);
  for(let y=0;y<ph;y++){
    for(let x=0;x<pw;x++){
      const i = y*pw + x;
      const left = x>0 ? scaledLum[i-1] : scaledLum[i];
      const right = x<pw-1 ? scaledLum[i+1] : scaledLum[i];
      const top = y>0 ? scaledLum[i-pw] : scaledLum[i];
      const bottom = y<ph-1 ? scaledLum[i+pw] : scaledLum[i];
      gx[i] = right - left;
      gy[i] = bottom - top;
    }
  }

  for(let y=0;y<ph;y++){
    for(let x=0;x<pw;x++){
      const i = y*pw + x;
      const dx = -gx[i] * (strength/50);
      const dy = -gy[i] * (strength/50);
      let sx = Math.round(x + dx), sy = Math.round(y + dy);
      if(sx<0) sx=0; if(sx>=pw) sx=pw-1;
      if(sy<0) sy=0; if(sy>=ph) sy=ph-1;
      const si = (sy*pw + sx)*4, oi = i*4;
      outData[oi] = pData[si]; outData[oi+1] = pData[si+1]; outData[oi+2] = pData[si+2]; outData[oi+3] = pData[si+3];
    }
  }
  dctxHR.putImageData(out, 0, 0);

  // blend displacedHR onto tmp (shirt already drawn)
  tctx.globalAlpha = patternState.alpha;
  tctx.globalCompositeOperation = 'multiply';
  tctx.drawImage(displacedHR, 0, 0);
  tctx.globalCompositeOperation = 'source-over';
  tctx.globalAlpha = 1;

  // apply mask scaled to tmp size
  if(maskCanvas){
    const mCanvas = document.createElement('canvas'); mCanvas.width = tmp.width; mCanvas.height = tmp.height;
    const mctx = mCanvas.getContext('2d');
    mctx.drawImage(maskCanvas, 0, 0, tmp.width, tmp.height);
    tctx.globalCompositeOperation = 'destination-in';
    tctx.drawImage(mCanvas, 0, 0);
    tctx.globalCompositeOperation = 'source-over';
  }

  const link = document.createElement('a');
  link.download = 'mockup.png';
  link.href = tmp.toDataURL('image/png');
  link.click();
});

// helper: scale luminance map (nearest)
function scaleLumMap(src, sw, sh, tw, th){
  if(!src) return null;
  const out = new Float32Array(tw*th);
  for(let y=0;y<th;y++){
    for(let x=0;x<tw;x++){
      const sx = Math.floor(x * sw / tw);
      const sy = Math.floor(y * sh / th);
      out[y*tw + x] = src[sy*sw + sx];
    }
  }
  return out;
}

// init
function syncUI(){ posX.value = Math.round(patternState.x); posY.value = Math.round(patternState.y); scaleEl.value = patternState.scale; rotationEl.value = patternState.rot; opacityEl.value = patternState.alpha; }
function init(){ syncUI(); draw(); }
init();

</script>

</body>
</html>